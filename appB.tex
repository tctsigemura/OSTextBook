\chapter{メモリ割付けプログラムの例}
\label{tacosMalloc}

TacOS を例に，
ファーストフィット方式を用いる可変区画方式のメモリ管理プログラムを紹介する．
以下で紹介するプログラムは{\cmm}言語で記述してある．
また，プログラムのオリジナル版は，
\url{https://github.com/tctsigemura/TacOS/blob/master/os/mm/mm.cmm}
から入手可能である．
このプログラムは，
OS内部でプロセスの生成時に，
プロセスの領域を割り付けるために使用されるものである\footnote{
本当は，PCBの割付け等，プロセス生成以外でも使用されている．}．
プロセス内部でヒープ領域を管理するプログラム
（{\tt malloc()}、{\tt free()}）のアルゴリズムも基本は同じである．

\section{データ構造の初期化}
メモリ管理用構造体({\tt MemBlk}）の宣言と，
初期化プログラムをリスト\ref{memBlk}に示す．
変数{\tt memPool}と番兵（{\tt MemBlk}構造体）は，
OSカーネルがメモリにロードされた時点で，
OSカーネルのデータ領域に初期化された状態で置かれる．
{\tt \_end()}関数はOSカーネルが使用している領域の
最後のアドレス（空き領域の先頭のアドレス）を知るために用いる特殊な関数である．
{\tt mmInit()}関数はカーネルが起動する際に一度だけ実行され
データ構造の初期化を行う．
{\tt mmInit()}関数は，まず，空き領域の先頭部分を {\tt MemBlk} 構造体と見做し
番兵の{\tt next}がこの構造体を指すようにする（15行）．
次に空き領域サイズを計算し，この構造体の{\tt size}に代入する（16行）．
最後にこの構造体がリストの最後になるように
{\tt next}に{\tt null}を代入する（17行）．

\begin{figure}[btph]
\lstinputlisting[label=memBlk, caption=データ構造と初期化]
{Lst/memBlk.cmm}
\end{figure}

以上の初期化処理が完了した時点のデータ構造を\figref{mmInit}に示す．
このとき，
{\tt memPool}変数を起点に番兵付きで長さが1の空き領域リストが完成している．

OSカーネルはメモリの{\tt 0000}番地から配置されている．
この領域にOSカーネルのプログラムとデータがロードされる．
図では分かりにくいが，{\tt memPool}変数と番兵はこの領域に配置される．
最初は，OSカーネルの直後からメモリ最後の使用不可領域の直前までが
一つの空き領域になっている．
空き領域の先頭に{\tt MemBlk}構造体を置いたと見做し，
番兵がそこを指すように初期化する．
空き領域の先頭の{\tt MemBlk}構造体が空き領域サイズを記憶し，
{\tt E000H}番地まで空き領域が続いていることを表現している．

\myfigure{btp}{scale=0.66}{Fig/mmInit-crop.pdf}
{初期化直後のデータ構造}{mmInit}

\section{メモリの割り付け}
メモリ領域の割り付けは{\tt mmAlloc()}関数が行う．
{\tt mmAlloc()}関数は引数に与えられたバイト数の領域を割り付け，
領域の先頭アドレスを返す．
リスト\ref{alloc}の手順で1KiBの領域を三つ割り付けた状態を
\figref{mmAlloc}に示す．
{\tt mmAlloc()}は，空き領域の前の方に要求された大きさの領域を割り付ける．
リスト\ref{alloc}では{\tt mmAlloc()}が3回実行され，
メモリの先頭に1KiBの使用中領域を三つ割り付けている．
その結果，空き領域が小さくなっている．

\begin{lstlisting}[float=btp,label=alloc, caption=1KiBの領域を三つ割り付ける]
a = mmAlloc( 1024 );      // 1KiB の領域を割り付ける
b = mmAlloc( 1024 );      // 1KiB の領域を割り付ける
c = mmAlloc( 1024 );      // 1KiB の領域を割り付ける
\end{lstlisting}

\myfigure{btp}{scale=0.66}{Fig/mmAlloc-crop.pdf}
{三つの領域を割り付けた状態}{mmAlloc}

リスト\ref{mmAlloc}に{\tt mmAlloc()}関数の本体を示す．
{\tt mmAlloc()}関数は領域の要求サイズ（2行目の{\tt siz}）を引数に呼び出され，
割り付けた領域のアドレスを整数（{\tt int}型）で返す．
実際に割り付ける領域は，
要求されたサイズに{\tt MemBlk}構造体のサイズを加えた後に
偶数に切上げた大きさである（3行目）．
TaCでは16bitデータ（2バイトデータ）をメモリに格納する時，
連続した$2i$番地と$2i+1$番地（$i$は適当な整数）を使う決まりになっているので，
領域は常に偶数番地から始まるようにする必要がある\footnote{
割り当てた領域に2バイトデータの配列として使用される場合を想像して欲しい．}．

{\tt mmAlloc()}関数は，
空き領域リストを探索し割り付けるサイズ以上の領域を見つける（7行〜）.
サイズ比較に使用される{\tt \_uComp()}関数は符号なし整数用の大小比較関数である.
領域を探す間はポインタ{\tt m}が目的の領域を,
ポインタ{\tt p}が一つ前の領域を指している.
リストの最後に達した場合は，適切な領域が見つからなかったことになる．
{\tt mmAlloc()}関数は{\tt 0}を返して終了する．

適切な領域（{\tt m}）が見つかったら，
それを使用領域と空き領域に分割するべきか判断する（13行）．
ちょうどピッタリか少しだけ大きい領域なら分割しない．
分割しない場合は領域をリストから外す（16行）．

分割する場合は領域の前半（{\tt m}）を使用領域，残りを空き領域とする．
空き領域のアドレスは，
アドレス用の足算関数{\tt \_addrAdd()}で{\tt n}に求める（18行）．
領域{\tt m}をリストから外し
代わりに領域{\tt n}をリストに挿入する（19行〜21行）．
領域{\tt n}の大きさを設定する（22行）．

最後に，
領域{\tt n}が正当に割当てられたことを表すマジックナンバー（{\tt MAGIC}）を
{\tt next}に書込む（24行）．
{\tt mmAlloc()}関数が返すアドレスは{\tt MemBlk}構造体直後である（25行）．
{\tt MAGIC}は{\tt mmFree()}関数が領域を解放する時に，
正当に割当てられた領域かどうかチェックするために使用される．

\begin{figure}[btph]
  \lstinputlisting[label=mmAlloc, caption=メモリ割り付けプログラム]
                  {Lst/mmAlloc.cmm}
\end{figure}

\section{メモリの解放}
{\tt mmFree(b);}を実行し領域{\tt b}を開放した状態を\figref{mmFree1}に示す．
続けて{\tt mmFree(c);}実行し領域{\tt c}も開放した状態を\figref{mmFree2}に示す．
\figref{mmFree1}では，領域{\tt b}が開放され空き領域が二つになり，
空き領域リストの長さが2になっている．
\figref{mmFree2}では，
領域{\tt c}が開放され空き領域を一つに合体することができたので，
空き領域リストの長さが1になっている．

\begin{figure}[btp]
\begin{center}
\begin{minipage}{0.49\columnwidth}
\includegraphics[scale=0.66]{Fig/mmFree1-crop.pdf}
\caption{領域bを開放した状態}\label{fig:mmFree1}
\end{minipage}
\begin{minipage}{0.49\columnwidth}
\includegraphics[scale=0.66]{Fig/mmFree2-crop.pdf}
\caption{領域cも開放した状態}\label{fig:mmFree2}
\end{minipage}
\end{center}
\end{figure}

メモリの解放を行う{\tt mmFree()}関数の本体をリスト\ref{mmFree}に示す．
{\tt mmFree()}関数は解放する領域{\tt mem}を引数に実行される（2行）．
領域の{\tt MemBlk}構造体に{\tt MAGIC}が格納されていない場合は
{\tt mmAlloc()}関数で割り付けられた正当な領域では無いので
エラーを表示してシステムを停止する（8行）\footnote{
このプログラムはOS内部で動くものである．
このような事象が発生するのはOSのバグが原因と考えられるので
システムを停止する．}．

解放された領域は新しい空き領域になる．
空き領域リストがアドレス順になるように，
新しい空き領域を挿入すべき位置を探す処理を行う（10行〜）．

解放する領域が直前の空き領域に重なっていたり，
直後の空き領域に重なっていたりしていないかチェックしている（19行）\footnote{
これもOSのバグ以外では発生しない．
OS自身がバグを含んでいないかチェックする機会として利用している．}．

解放する領域が直前の空き領域に隣接している場合は，
直前の空き領域サイズを大きくすることで一つの空き領域にしてしまう（23行）．
直後の空き領域とも隣接している場合は，
直前の空き領域サイズを更に大きくし直後の空き領域も一つの領域にする（25行）．
この時は，空き領域が一つにまとめられたので，
空き領域リストから直後の空き領域を削除する（26行）．

更に，直後の空き領域だけと隣接している場合（28行），
どの空き領域とも隣接していない場合（32行）の処理が続いている．

\begin{figure}[btph]
\lstinputlisting[label=mmFree, caption=メモリ解放プログラム]
{Lst/mmFree.cmm}
\end{figure}
