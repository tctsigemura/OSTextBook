\chapter{TacOSのファイルフォーマット}
\label{appTacosFileFormat}
TacOSと{\cmml}サポートユーティリティ\footnote{
  詳細は\url{https://github.com/tctsigemura/Util--}を参照のこと．
}が使用する３種類のバイナリ形式ファイルの内容について解説する．
{\cmml}サポートユーティリティは，
クロスアセンブラ{\as}，
クロスリンカ{\ld}，
クロスローダ{\objbin}，
実行形式ファイル作成プログラム{\objexe}
からなる．

%==============================================================================
\section{\texttt{.o} 形式ファイル}
{\as}が出力する再配置可能な機械語ファイル形式である．
{\ld}は，複数の\texttt{.o}形式ファイルを入力し一つに結合する．
結合されたファイルも同じ\texttt{.o} 形式ファイルになる．

\subsection{ファイル形式}
\figref{tacosOformat}に\texttt{.o} 形式ファイルのフォーマットを示す．
なお，TaCの1ワードは16ビットである．

\begin{myfig}{btp}{\texttt{.o}ファイルフォーマット}{tacosOformat}
\begin{tabular}{|c|}\hline
ヘッダ(8ワード) \\\hline
\\
テキストセグメント \\
\\\hline
\\
データセグメント \\
\\\hline
テキストリロケーション \\\hline
データリロケーション \\\hline
シンボルテーブル \\\hline
文字列テーブル \\\hline
\end{tabular}
\end{myfig}

\subsection{ヘッダ}
\texttt{.o}形式ファイルのヘッダは次の構造体により定義される．
ただし，ここで\|uint|型は符号無しの 16 ビット整数型である．

\begin{lstlisting}[numbers=none,float=htb]
struct ObjHdr {
  uint magic;     // マジックナンバー(0x0107)
  uint text;      // テキストセグメントサイズ(バイト単位)
  uint data;      // 初期化データセグメントサイズ(バイト単位)
  uint bss;       // 非初期化データセグメント(BSS)サイズ(バイト単位)
  uint syms;      // シンボルテーブルサイズ(バイト単位)
  uint entry;     // 常に 0
  uint trsize;    // テキストリロケーションサイズ(バイト単位)
  uint drsize;    // データリロケーションサイズ(バイト単位)
};
\end{lstlisting}

\subsection{リロケーションレコード}
テキストリロケーション，データリロケーション領域には，
再配置情報を記録したリロケーションレコードの表が格納される．
リロケーションレコードは次の構造体で定義される．
レコードは 2 ワード長で，
第1ワードが再配置時に書き換えが必要なポインタのセグメント中アドレス，
第2ワードは上位2ビットがポインタの種類(\|type|)データ，
下位14ビットがポインタ値を格納するシンボルの
シンボルテーブル上の添字(\|idx|)データである．

\begin{lstlisting}[numbers=none,float=htb]
struct ObjRel {
  uint addr;       // 再配置すべきポインタのセグメント内アドレス
  uint type: 2,    // ポインタの型
       idx: 14;    // シンボルテーブルのポインタが登録されている位置
};

// type の意味
#define UNDEF 0    // 未定義
#define TEXT  1    // テキストセグメント
#define DATA  2    // データセグメント
#define BSS   3    // コモン
\end{lstlisting}

\subsection{シンボルテーブル}
シンボルテーブルは，シンボルとアドレスを対応付けを行う．
アセンブラが処理したシンボル(ラベル)の中で\|EQU|ラベルを除くもの全てが
シンボルテーブルに出力される．
また，アセンブラのソースプログラムのファイル名もシンボルテーブルに出力され，
{\objexe}，{\objbin}プログラムがファイル名とともに
エラー表示ができるようにしている．
シンボルは 1 文字目によって意味付けがされる．
意味は，「\|@| : ファイル名」，「\|.| : ローカル名」，
それ以外はグローバルな名前になる．
シンボルテーブルを構成するシンボルレコードの構成を次に示す．

\begin{lstlisting}[numbers=none,float=htb]
struct Symbol {
  uint type: 2,    // シンボルの型
       sIdx:14;    // シンボル名称の文字列テーブル上の位置
  uint val;        // シンボルの値
};

// type の意味
#define UNDEF 0    // 未定義
#define TEXT  1    // テキストセグメント
#define DATA  2    // データセグメント
#define BSS   3    // コモン
\end{lstlisting}

シンボルレコードは 2 ワード長である．
第1ワードの上位 2 ビットがシンボルの種類(\|type|)を表し，
下位14ビットが文字列テーブル上で
シンボルの綴が格納されている場所を表す添字データ(\|sIdx|)を格納する．
第2ワード(\|val|)はシンボルの値をセグメント内オフセットで表す．
ただし，未定義(\|UNDEF|)シンボルの場合は\|0|，
コモン(\|BSS|)シンボルの場合は領域のサイズを格納する．

{\ld}は，複数の入力ファイル中に同名のコモンシンボルを発見した場合，
それらを一つの領域に重ね合わせる．
このとき，領域のサイズは重ね合わせたシンボルの中で最大のもになる．
また，
一つのデータセグメントシンボルと一つ以上のコモンシンボルが見つかった場合は，
データセグメントシンボルに集約する．
未定義シンボル同士は一つの未定義シンボルに，
未定義シンボルと他の種類のシンボルは未定義ではない方のシンボルに集約する．
これ以外に同名のシンボルが見つかった場合は，
エラー(シンボルの2重定義)になる．

\subsection{文字列テーブル}
文字列テーブルはシンボルの綴を格納する．
文字列テーブルの内容は{\cmml}型文字列の繰返である．
{\cmml}型文字列は， \|\0| で終端された8ビットの文字コード配列である．
ヘッダに文字列表のサイズは格納されていないので，
ファイルサイズから文字列テーブルのサイズを知る必要がある．

シンボルテーブルに同じ綴のシンボルが複数ある場合
(「\|.|」で始まるローカルシンボルは同じ綴の可能性がある)は，
メモリの節約のため，
複数のシンボルレコードで同じ文字列表エントリーを共用する．
{\cmm}コンパイラが自動的に生成するローカルラベルは，
毎回，同一のパターンなので，
多くのシンボルレコードで文字列表エントリーが共用される．

%==============================================================================
\section{\texttt{.exe} 形式ファイル}
TacOSの実行可能なアプリケーションプログラムファイルである．
内容は，再配置可能な機械語ファイル形式から，
実行時に不要な情報を取り除いたものである．
プログラムをロードする処理を簡単にしカーネルを小さくするために，
\texttt{.o} を簡単化したファイル形式を準備した．
{\objexe}は，\texttt{.o} 形式のファイルを一つ入力して，
\texttt{.exe} ファイルを一つ出力する．
未定義シンボルを含む\texttt{.o}形式ファイルは，
\texttt{.exe}形式ファイルに変換することができない．

\subsection{ファイル形式}
\figref{tacosEformat}に\texttt{.exe} 形式ファイルのフォーマットを示す．
\texttt{.o} 形式ファイルを簡単化したファイル形式である．

\begin{myfig}{btp}{\texttt{.exe}ファイルフォーマット}{tacosEformat}
  \begin{tabular}{|c|} \hline
    ヘッダ(6ワード) \\\hline
    \\
    テキストセグメント \\
    \\\hline
    \\
    データセグメント \\
    \\\hline
    リロケーション \\\hline
  \end{tabular}
\end{myfig}

\subsection{ヘッダ}
\texttt{.exe}形式ファイルのヘッダは次の構造体により定義される．
% ただし，ここで\|uint|型は符号無しの16ビット整数型とする．

\begin{lstlisting}[numbers=none,float=htb]
struct ExeHdr {
  uint magic;     // マジックナンバー(0x0108)
  uint text;      // テキストセグメントサイズ(バイト単位)
  uint data;      // 初期化データセグメントサイズ(バイト単位)
  uint bss;       // 非初期化データセグメント(BSS)サイズ(バイト単位)
  uint rsize;     // リロケーションサイズ(ワード単位)
};
\end{lstlisting}

\subsection{リロケーションレコード}
リロケーション領域には，
再配置情報を記録したリロケーションレコードの表が格納される．
リロケーションレコードは次の構造体で定義される．
レコードは 1 ワード長で，
再配置時に書き換えが必要なポインタの格納アドレスを表現する．

\begin{lstlisting}[numbers=none,float=htb]
struct ExeRel {
  uint addr;       // 再配置すべきポインタのアドレス(バイト単位)
};
\end{lstlisting}

%==============================================================================
\section{\texttt{.bin} 形式ファイル}
ロードアドレスが確定した機械語プログラムを格納するためのファイル形式である．
この形式のプログラムはメモリにロードするだけで実行できる．
{\objbin}プログラムによって\texttt{.o}形式ファイルを
\texttt{.bin}形式ファイルに変換する．
未定義シンボルを含む\texttt{.o}形式ファイルは，
\texttt{.bin}形式ファイルに変換することができない．

\subsection{ファイル形式}
8ビット版の TeC で使用してきた \texttt{.bin} 形式ファイルを
単純に16ビットに拡張した形式のファイルである．
\figref{tacosBformat}にファイルの形式を示す．
第1ワードが機械語プログラムのロードアドレス，
第2ワードが機械語プログラムの長さ(バイト単位)を表現する．
第3ワードから先は機械語プログラム本体である．
プログラム本体は，テキストセグメント，初期化データセグメント，
非初期化セグメントを結合したものである．
非初期化セグメントは，\|0x00|で満たされている．

\begin{myfig}{btp}{\texttt{.bin}ファイルフォーマット}{tacosBformat}
  \begin{tabular}{|c|}
    \hline
    ロードアドレス(1ワード) \\\hline
    プログラム長(1ワード) \\\hline
    \\
    機械語プログラム \\
    (プログラム長バイト)\\
    \\\hline
  \end{tabular}
\end{myfig}

\texttt{.bin} 形式ファイルはリロケーションレコードを持たず，
ロードアドレスが確定した機械語プログラムを格納する．
IPLプログラム(\texttt{ipl.bin})，
OS カーネルプログラム(\texttt{kernel.bin})が，
この形式のプログラムファイルである．
