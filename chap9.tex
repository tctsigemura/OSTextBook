\chapter{メモリ割付け方式}
プロセスが実行を開始する前に，
物理メモリの一部をプロセスに割付け，
プログラムをロードする．
物理メモリを複数のプロセスで分割し利用するために，
幾つかの方式が考案されてきた．
ここでは，固定分割方式と可変分割方式について解説する．

%============================================================================
\section{固定区画方式}
予めメモリを大小数種類の区画に分割しておく．
プロセスのサイズにより適切な区画を選択し利用する．
その様子を\figref{fixedPartition}に示す．

\myfigure{btp}{scale=0.6}{Fig/fixedPartition-crop.pdf}
{固定区画方式}{fixedPartition}

\figref{fixedPartition}の例では
利用可能なメモリは予め五つの区画に分割されている．
プロセス１から４を実行したい時，
ロード可能な区画を選択しロードする．
プロセス４はロード可能な区画が無いので実行できない．

区画の大きさとプロセスの大きさは一致するとは限らない．
一致しない場合は区画１から３ように，
内部に使用されない領域（{\bf 内部フラグメント}）が生じる．
区画４と区画５を合わせるとプロセス４をロード可能であるが，
固定区画方式では組合せて利用することはできない．
仕組みが簡単だがメモリの利用率が低い．
特徴を以下にまとめる．

\begin{enumerate}
\item 空き領域の管理が容易である．
\item 領域内部に無駄な領域（{\bf 内部フラグメント}）が生じる．
\item 小さな領域が複数空いていても大きなプロセスは実行できない．
\item 実行可能なプロセスのサイズに強い制約がある．\\
（図の例では，151KiBのプロセスは実行できない．）
\item 同時に実行できるプロセスの数に制約がある．\\
（図の例では，同時に五つ以上のプロセスは実行できない．）
\end{enumerate}

%============================================================================
\section{可変区画方式}
メモリの空き領域から，
プロセスのサイズに合わせたメモリ区画を割付ける方式である．
\figref{variablePartition}に模式図を示す．

\myfigure{btp}{scale=0.6}{Fig/variablePartition-crop.pdf}
{可変区画方式}{variablePartition}

\begin{enumerate}
\item[(a)] 初期状態 \\
メモリはカーネルと，大きな単一の空き領域に分割される．
\item[(b)] 実行開始 \\
\figref{fixedPartition}と同じ四つのプロセスがロードされ実行を開始した．
\figref{fixedPartition}の例では実行できなかった「プロセス4」も実行できる．
（メモリの利用効率は良い．）
\item[(c)] プロセス1（P1）終了 \\
終了したプロセスが利用していた領域は，
再利用可能な空き領域になる．
\item[(d)] プロセス5（P5），プロセス6（P6）実行開始 \\
120KiBの空き領域は，
「110KiBの領域」と「10KiBの空き領域」に分割する．
100KiBの空き領域は，
「80KiBの領域」と「20KiBの空き領域」に分割する．
プロセス5とプロセス6を新しい領域にロードし実行する．
\item[(e)] プロセス3（P3）終了 \\
プロセス3が利用していた領域は，
再利用可能な40KiB空き領域になる．
メモリ全体では，10KiB，40KiB，20KiBの空き領域ができている．
\end{enumerate}

以上のように可変区画方式では，
プロセスの開始と終了が繰り返されるに従い小さな空き領域ができる．
このような区画の外にできる小さなメモリ領域を{\bf 外部フラグメント}と呼ぶ．

%============================================================================
\section{可変区画方式の空き領域選択方式}
以下の三つの方式が知られている．
\figref{firstBestWorstFit}に三つの方式で選択される空き領域の例を示す．

\myfigure{btp}{scale=0.6}{Fig/firstBestWorstFit-crop.pdf}
{空き領域の選択方式}{firstBestWorstFit}

\begin{itemize}
\item {\bf ファーストフィット（first-fit）方式}\\
アドレス順に空き領域を探索し，
最初に見つかった十分な大きさの領域を選択する．

\item {\bf ベストフィット（best-fit）方式}\\
プロセスを格納可能な領域の中で最小のものを選択する．

\item {\bf ワーストフィット（worstfit）方式}\\
最も大きな領域を選択する．
\end{itemize}

シミュレーションの結果メモリ利用率の点で，
ワーストフィット方式は最も性能が劣るが，
ファーストフィットとベストフィットの性能は互角だと言われている．
しかし実行時間の点で，
ファーストフィットがベストフィットより優れていると言われている．

%============================================================================
\section{空き領域の管理方式}
プロセスによって使用中のメモリ区画は
プロセスのPCB等に記録しおけば見失う心配はない．
しかし，
どのプロセスにも属さない空き領域はメモリ管理側で記録しておく必要がある．

\begin{itemize}
\item {\bf ビットマップ（bitmap）方式}\\
\figref{bitMap}のようにメモリを一定の大きさのブロックに分割し，
1ブロックをビットマップの1ビットに対応させる．
ビットが 0 ならブロックが空き状態，
ビットが 1 なら使用中の意味になる．
% 後で述べるページング方式において，
% 空きページを管理するにはこの方式が適している．

\myfigure{btp}{scale=0.6}{Fig/bitMap-crop.pdf}
{ビットマップ方式}{bitMap}

ビットマップはメモリ上に記録する．
ビットマップの大きさは次のように計算できる．
仮に8GiBのメモリを4KiBのブロックに分割して管理すると仮定すると，
ブロックの総数は
$8GiB \div 4KiB = (8\times 2^{30}) \div (4 \times 2^{10}) = 2 \times 2^{20}$
個となる．
ビットマップの大きさはブロック数と同じ$2 \times 2^{20}$ビットになる．
これをバイト単位に換算すると，
$(2 \times 2^{20}) \div 8 = 2^{18} = 256KiB$
となる．

ビットマップに使用するメモリは無視できるほど小さいものではない．
ビットマップをより小さくするにはブロックサイズを大きくすれば良い．
しかし，ブロックサイズを大きくすると内部フラグメントが大きくなる．

\item {\bf リスト（linked-list）方式}\\
空き領域をリストにして管理する方式である．
使用中の領域が解放されると空き領域リストに追加される．
解放される領域が，
別の空き領域に隣接している場合は一つの空き領域になる．
その様子を\figref{memFree}に示す．

\myfigure{btp}{scale=0.66}{Fig/memFree-crop.pdf}
{領域開放時に空き領域を連結する様子}{memFree}

リスト方式で用いるデータ構造の例を\figref{linkedList}に示す．
新しい空き領域と前後の空き領域をマージする処理が簡単に行えるように，
空き領域はアドレス順にソートしてリストに挿入される．

\myfigure{btp}{scale=0.5}{Fig/linkedList-crop.pdf}
{空き領域リスト}{linkedList}

アドレス順に領域がソートしてあると，
ファーストフィット方式で領域を探索するためにも適している．
ベストフィット方式の場合は領域サイズ順にソートしてあると良いが，
前述の空き領域のマージ処理には適さない．

\end{itemize}

%============================================================================
\section{実装例}
付録\ref{tacosMalloc}にTacOSのメモリ割付けプログラムの例を示す．
この例は，
ファーストフィット方式，可変区画方式のメモリ管理プログラムを{\cmm}言語で
実装したものである．

%============================================================================
\subsection*{練習問題}
可変区画方式で管理される100KiBの空き領域がある時，
次の順序で領域の割付け解放を行った．
ファーストフィット方式を用いた場合と
ベストフィット方式を用いた場合について，
実行後のメモリマップを図示しなさい．

\begin{enumerate}
\item 30KiBの領域を割付け
\item 40KiBの領域を割付け
\item 20KiBの領域を割付け
\item 先程割付けた40KiBの領域を解放
\item 10KiBの領域を割付け
\end{enumerate}
