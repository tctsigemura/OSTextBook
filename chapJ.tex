\chapter{TacOSのCPU仮想化}
\label{tacosVirtualCPU}
CPU仮想化の実例としてTacOS\footnote{TacOSの詳細は
  \url{https://github.com/tctsigemura/TacOS}
  を参照のこと．}の例を紹介する．
TacOSはマルチプロセスのオペレーティングシステムである．
以下ではCPUの時分割多重に必要なプロセス切換え機構を紹介する．

%==============================================================================
\section{PCB}
PCBはプロセス切換え機構にとっても最も重要なデータ構造である．
PCBは，リスト\ref{tacosPCB}に示す\|PCB|構造体として定義されている\footnote{
  \url{https://github.com/tctsigemura/TacOS/blob/master/os/kernel/process.hmm}
  の一部である．}．
\|PCB|構造体の内容を順に説明する．

\lstinputlisting[firstline=68,lastline=96,numbers=left,label=tacosPCB,
  float=btp,caption=TacOSのPCB宣言ソースプログラム]{TacOS/kernel/process.hmm}

\begin{itemize}
\item 仮想CPU(\|sp|） \\
  プロセスのコンテキストのほとんどをカーネルスタック上に保存する．
  そして，保存位置を表すスタックポインタ（SP）だけをPCBに保存する．
  カーネルスタックはプロセス毎に準備されている．
  PCBに保存されるのは仮想CPUの一部（SP）だけである．
\item プロセス番号（\|pid|）
\item 状態（\|stat|） \\
  プロセスの状態は以下の三つである．
  \begin{enumerate}
  \item \|P_RUN| \\
    RunningとReadyの二つを兼用している．
    プロセスは実行可能プロセスの待ち行列（実行可能列）に挿入される際に
    \|P_RUN|状態になる．
    実行中も\|P_RUN|状態のまま変更しない．
  \item \|P_WAIT| \\
    Waiting状態のことである．
  \item \|P_ZOMBIE| \\
    プロセスが終了したが，終了ステータスを親プロセスに渡していない状態である．
    終了処理の途中状態と考えるとよい．
  \end{enumerate}
\item 優先度（\|nice|，\|enice|） \\
  ゼロが最も高い優先度を表す．
  優先度には，
  本来の優先度（\|nice|）と，
  実質の優先度（\|enice|）の二つがある．
  現在の実装ではこの二つは同じ値を持つ．
  将来，動的に変化する優先度を採用する場合に，
  \|enice|の値が変化するようにする．
\item プロセステーブルのインデクス（\|idx|） \\
  このPCBが登録されているプロセステーブル内の位置である．
  プロセスが消滅する際にプロセステーブルからPCBを削除するために使用する．
\item イベント用カウンタとセマフォ（\|evtCnt|，\|evtSem|） \\
  セマフォはプロセス間の同期に使用する基本的な機構である\footnote{
    詳しくは第\ref{tacosImpSemaphore}章で解説する．}．
  タイマー待ち，子プロセスの終了待ち等で，
  このセマフォを使用してプロセスを待ち状態にする．
  カウンタはタイマーの待ち時間を計るため等に使用される．
\item プロセスのアドレス空間（\|memBase|，\|memLen|） \\
  仮想記憶のような高度な機構は無い．
  各プロセスは，
  物理メモリの領域をオペレーティングシステムによって割付けられる．
  \|memBase|は
  オペレーティングシステムがプロセスに割当てたメモリ領域の開始アドレス，
  \|memLen|はメモリ領域のバイト数である．
\item プロセスの親子関係の情報（\|parent|，\|exitStat|） \\
  プロセスは親プロセスだけ記憶している．
  \|parent|は親プロセスのPCBを指すポインタである．
  \|exitStat|は\|P_ZOMBIE|状態になった時，
  親に渡すべき終了ステータスを保存する領域である．
\item オープン中のファイル一覧（\|fds|） \\
  プロセスがオープンしたファイルのファイルディスクリプタ（番号）の
  一覧を記憶する配列である．
  システム全体で一意なファイルディスクリプタ（番号）が用いられる\footnote{
    UNIXのファイルディスクリプタ（番号）はプロセス毎に0番から割振られる．}．
  \|close()|システムコールは，
  クローズするファイルディスクリプタが正当なものか調べるために，
  この配列を使用する．
  \|exit()|システムコールは，
  プロセスを終了する前にプロセスの全オープンファイルをクローズするために，
  この配列を使用する．
\item PCBリストの管理（\|prev|，\|next|） \\
  プロセスのリストをPCBのリストとして表現する．
  PCBリストは番兵付きの双方向循環リストである（\figref{tacosReadyQueue}参照）．
  \|prev|，\|next|はリスト上で前後のプロセスのPCBを指すポインタである．
\item スタックオーバーフローの検知（\|magic|） \\
  PCBの直後にプロセスのカーネルスタックを配置する．
  万一，カーネルスタックがオーバーフローするとPCBが後ろから破壊される．
  \|magic|はそれを検知するために使用される．
  PCBを初期化する際に\|magic|に\|0xabcd|を格納する．
  カーネルスタックがオーバーフローすると，まず，\|magic|領域が破壊される．
  \|magic|の値が変化していないかチェックすることで，
  カーネルスタックのオーバーフローを検知することができる．
\end{itemize}

%==============================================================================
\section{実行可能列}

\begin{myfig}{btp}{TacOSの実行可能列}{tacosReadyQueue}
  \includegraphics[scale=0.6]{Fig/tacosReadyQueue-crop.pdf}
\end{myfig}

実行可能列は，
\figref{tacosReadyQueue}に示すようなPCBの番兵付き双方向循環リストある．
番兵の次のプロセスが最も優先度が高い実行可能なプロセスである．
プロセスをディスパッチする際は，番兵の次のプロセスを選択する．
選択されたプロセスを\|curProc|が指すように変更してからディスパッチする．
プロセス実行時も，PCBは実行可能列に置いたままにする．
プロセスがブロックする際は，
\|curProc|を実行可能列からイベントの待ち行列に移動する．
% 次回のディスパッチでは，
% 再度，実行可能列の優先度が最も高いプロセスを選択し，
% \|curProc|が指すように変更する．

%==============================================================================
\section{メモリ配置}
\figref{tacosMemMap}にTacOS実行時のメモリマップを示す．
図は二つのプロセスが実行中の例である．
まず「物理メモリ空間」の配置について，
次に「PCBとカーネルスタック」について説明する．

\begin{myfig}{btp}{TacOSのメモリ配置}{tacosMemMap}
  \includegraphics[scale=0.6]{Fig/tacosMemMap-crop.pdf}
\end{myfig}

\begin{enumerate}
\item[(a)] 物理メモリ空間
  \begin{itemize}
  \item カーネル \\
    マイクロカーネルとサーバプロセスを一つのプログラムにリンクしたものを
    \emph{カーネル}と呼ぶことにする．
    カーネルのプログラムとデータ（変数）がこの領域に配置される．
  \item プロセス＃１のPCBとカーネルスタック \\
    プロセス１のPCBとカーネルスタックが隣接して配置される．
  \item プロセス＃２のPCBとカーネルスタック \\
    プロセス毎にPCBとカーネルスタックが準備される．
  \item プロセス＃１のメモリ空間 \\
    プロセス１のプログラム，データ，ヒープ，スタック領域が配置される．
    ユーザモードのプロセスは，
    この範囲以外のメモリをアクセスできないように保護すべきである．
    しかし，TaCはメモリ保護機構を持っていない．
  \item プロセス＃２のメモリ空間 \\
    プロセス毎にメモリ空間が準備される．
  \end{itemize}
\item[(b)] PCBとカーネルスタック \\
  \figref{tacosMemMap}に示すように，
  PCBとカーネルスタックは隣接して配置される．
  ユーザプロセス実行中はカーネルスタックの内容は空になる．
  %（スタックポインタがスタック領域の最大アドレスを指す．）．
  カーネルモードで動作するサーバプロセスはカーネルスタックを使用する．
  割込みが発生するとPSWとCPUレジスタをカーネルスタックに保存した後，
  マイクロカーネル内ルーチンの実行が始まる．
  マイクロカーネル内ルーチンはカーネルスタックを使用する．
  万一，カーネルスタックが伸びすぎてPCBを破壊した場合は，
  PCBのスタック寄りに置いたマジックナンバー（\|0xabcd|）が書き換わる．
  プロセススイッチの際にマジックナンバーを調べ，
  PCBが破壊されていないことを確認する．
\end{enumerate}

%==============================================================================
\section{割込み処理}
\label{tacosInterrupt}
TaCはベクタ方式の割込み機構を持っており，
割込み原因毎に割込みハンドラを登録することが可能である．
割込みが発生するとTaCのCPUは次の処理を自動的に行う．

\begin{enumerate}
\item カーネルスタックにPSWを保存する．
\item CPUをカーネルモードかつ割込み禁止に設定する．
\item 対応する割込みベクタに登録されているハンドラにジャンプする．
\end{enumerate}

以下では，タイマー割込みを例に割込みハンドラの振舞いと，
割込み発生時のカーネルスタックの状態を説明する．
リスト\ref{tacosTmr}\footnote{
  \url{https://github.com/tctsigemura/TacOS/blob/master/os/kernel/kernel.cmm}
  の一部である．
}にTacOSのタイマー管理プログラム部分を示す．

\lstinputlisting[firstline=463,lastline=491,numbers=left,label=tacosTmr,
  float=btp,caption=TacOSのタイマー管理プログラム]{TacOS/kernel/kernel.cmm}

\begin{itemize}
\item \emph{割込みハンドラの初期化} \\
  \|tmrInit()|関数はOS起動時に実行され，
  割込みハンドラ（\|tmrIntr()|）関数を
  \|0xffe0|番地から始まる割込みベクタに登録し，
  タイマーのハードウェアを起動する．
\item \emph{割込みハンドラ} \\
  \|interrupt|型の\|tmrIntr()|関数が割込みハンドラである．
  \figref{tacosMemMap}の右半分に示すように，
  \|interrupt|型の関数は自動的にコンテキストをスタックに保存する．
  \figref{tacosMemMap}では分かりやすさのためにユーザモードのコンテキストと
  している．

  \|tmrIntr()|関数はプロセステーブルの全てのプロセスについて（8行），
  タイマーの残り時間が0以下になるものを起こす（14行）．
  タイマー待ちのプロセスはPCBの\|evtSem|セマフォを用いてブロックしているので，
  \|iSemV()|関数\footnote{
    \ref{tacosVOP}節を参照すること．
  }を用いてプロセスを起こす．

  最後に，プロセス切換えの可能性があるなら\|yield()|関数\footnote{
    \ref{tacosProcSwitch}で詳しく説明する．
  }を呼び出し，
  プロセスを切り換えるチャンスを作る．
  プロセスが切り換わった場合は，20行を実行中の状態でプロセスがブロックする．
  21行で\|interrupt|関数が終了し，コンテキストが復元され，
  割込まれたプログラムが再開される．
\end{itemize}

%==============================================================================
\section{プロセス切換えプログラム}
\label{tacosProcSwitch}
プロセス切換えプログラムは，
コンテキストを保存する\|yield()|関数\footnote{
  高級言語から\texttt{yield()}関数を呼出すと，
  アセンブリ言語の\texttt{\_yield}ルーチンが実行される．
}と復旧する\|dispatch()|関数\footnote{
  高級言語から\texttt{dispatch()}関数を呼出すと，
  アセンブリ言語の\texttt{\_dispatch}ルーチンが実行される．
}からなる．
\|dispatch()|関数は実行可能列の先頭にあるプロセスを選択し
コンテキストを復旧する．

\subsection{\texttt{yield()}関数}
リスト\ref{tacosYield}\footnote{
  \url{https://github.com/tctsigemura/TacOS/blob/master/os/kernel/dispatcher.s}
  の一部である．
}にTaCのアセンブリ言語で記述した\|yield()|関数を示す．
\|yield()|関数がカーネルモードのコンテキストをカーネルスタックに保存する．
保存位置は\figref{tacosMemMap}に示した通りである．

\ref{tacosInterrupt}で述べたように割込が発生すると，
まず，割込みハンドラがユーザモードのコンテキストをカーネルスタックに保存する．
次に，カーネルモードでマイクロカーネル内のプログラムが実行される．
この時点では，割込み前のプロセスの一部として実行されている．
最後に，
マイクロカーネル内プログラムがプロセスを切換えるために\|yield()|を呼出す．
\|yield()|はカーネルモードのコンテキストをカーネルスタックに追加保存し，
新しいプロセスの実行に切換える．
%次回，プロセスの実行が再開されるのは，
%マイクロカーネル内の\|yield()|を呼出した位置になる．
次にリスト\ref{tacosYield}の内容を解説する．

\lstinputlisting[firstline=49,lastline=77,numbers=left,label=tacosYield,
  float=btp,caption=TacOSコンテキスト保存プログラム]{TacOS/kernel/dispatcher.s}

\begin{description}
\item[1行] プロセスを切換える時にマイクロカーネル内で呼出される
  \|yield()|関数の入口である．
  \|yield()|関数は，
  現在プロセスのカーネルモード・コンテキストを保存しCPUを解放する．
\item[2〜19行] プロセスのカーネルモードのコンテキストを
  スタックに保存する処理である．
  \|yield()|が（CALL命令で）呼出された時点でPCはスタックに格納されている．
  後でRETI命令でPCとFLAGを同時に復旧するのでPCの次にFLAGを格納している
  （6行）．
\item[21〜23行] プロセスのカーネルモードのコンテキストを
  保存したスタックの位置をPCBに保存する．
  \|_curProc|変数には現在のプロセスのPCBを指すポインタが保存されている
  （\figref{tacosReadyQueue}参照）．
  PCB先頭の\|sp|領域（リスト\ref{tacosPCB}参照）に
  スタックポインタを保存する．
  ここまでの処理でコンテキストの保存が完了した．
\item[25〜28行] カーネルスタックがオーバーフローしていないか調べる．
  PCBの\|magic|フィールドの値をチェックし
  \|0xabcd|以外の値になっていたら，
  カーネルスタックが隣接するPCBまで伸びた（オーバーフローした）と判断する．
  この場合，\|.stkOverFlow|ルーチンにジャンプしシステムを停止する．
  カーネルのエラーなので復旧は諦める．
  オーバーフローが検知されない場合は次の行に進む．
  次の行はリスト\ref{tacosDispatch}の1行に示す\|_dispatch|である．
  \|jnz|でジャンプしなかった場合はディスパッチャに進み次のプロセスを再開する．
\end{description}

\subsection{\texttt{dispatch()}関数}
リスト\ref{tacosDispatch}\footnote{
  \url{https://github.com/tctsigemura/TacOS/blob/master/os/kernel/dispatcher.s}
  の一部である．
}にTaCのアセンブリ言語で記述した\|dispatch()|関数のソースプログラムを示す．
\|dispatch()|関数がカーネルモードのコンテキストをカーネルスタックから復旧する．
復旧するコンテキストは\figref{tacosMemMap}に示したように保存されている．
次にリスト\ref{tacosDispatch}の内容を解説する．

\lstinputlisting[firstline=78,lastline=102,numbers=left,label=tacosDispatch,
  float=btp,caption=TacOSコンテキスト復旧プログラム]{TacOS/kernel/dispatcher.s}

\begin{description}
    \item[1行] プロセスにCPUを割り付ける
      ディスパッチャ（\|dispatch()|関数）の入口である．
    \item[2〜6行] まず，
      実行可能列（\|_readyQueue|）の先頭プロセスのPCBアドレスを
      \|_curProc|変数にセットする．
      実行可能列は番兵付きの双方向循環リストなので番兵の次が先頭のPCBである
      （\figref{tacosReadyQueue}参照）．
      実行可能なプロセスが無い場合はidleプロセスが選択される．
      \|_curProc|が更新されたので，新しいプロセスが現在のプロセスになった．
      次に，
      現在のプロセスの保存してあったスタックポインタ（\|sp|）を復旧する．
    \item[8〜22行] スタックポインタが復旧されたので，
      スタックからCPUレジスタを復旧する．
    \item[24〜25行] RETI命令を用いてPSW（FLAGとPC）を復旧し，
      前回プロセスが\|yield()|を呼出した位置に戻る．
      \|yield()|を呼出した位置に戻るためにRET命令ではなく
      RETI命令を使用するのは，
      プロセス生成時は例外的に，
      このRETIで実行モードを切換えてユーザプログラムの実行を
      開始するからである．
\end{description}

%==============================================================================
\section{スケジューラ}
\label{tacosScheduler}
実行可能になったプロセスをスケジューリングするプログラムを
\emph{スケジューラ}と呼ぶ．
スケジューラの例をリスト\ref{tacosSch}に示す\footnote{
  \url{https://github.com/tctsigemura/TacOS/blob/master/os/kernel/kernel.cmm}
  の一部である．}．
このプログラムは，
新しく実行可能になったプロセスを実行可能列に挿入する．
その際，実行可能列がプロセスの優先度順にソートされるようにする．
\|dispatch()|関数は実行可能列の先頭のプロセスを実行するので，
プロセスは優先度が高い順に実行される．
実行可能列はPCBの番兵付き双方向循環リストとして表現する
（\figref{tacosReadyQueue}参照）．
次にリスト\ref{tacosSch}の内容を解説する．

\lstinputlisting[numbers=left,firstline=129,lastline=137,
  float=btp,label=tacosSch,
  caption=TacOSのスケジューラ・ソースプログラム]{TacOS/kernel/kernel.cmm}

\begin{description}
\item[1行] \|schProc()|関数がスケジューラである．
\item[2行] \|setPri()|関数はPSWの割込み許可フラグを操作する\footnote{
  詳しくは「\ref{setPri} setPri()関数」で説明する．}．
  \|schProc()|関数はプロセス間の共有資源である実行可能列を操作するので
  クリティカルセクションである．
  プロセスがプリエンプションしないように，ここで割り込み禁止にしている．
\item[3行] \|enice|がプロセスの優先度である．
  \|enice|は値が小さい方が優先度が高い．
\item[4行] スケジューラは，
  実行可能列（\|readyQueue|）を番兵PCBの次のPCBから探索する．
\item[5〜6行] 挿入するプロセスの\|enice|より大きいものを探す．
  実行可能列の最後には，常時IdleプロセスのPCBが置かれている
  （\figref{tacosReadyQueue}参照）．
  Idleの\|enice|は最大値に設定されているのでループは必ず正常に終了する．
\item[7行] 大きいものを見つけたら\|insProc()|を使用して，
  見つけたPCBの直前に新しいプロセスのPCBを挿入する．
\end{description}

現在の実装では，\|enice|はプロセス生成時に\|nice|と同じ値に設定され，
その後は変化しない．
TacOSは\emph{静的優先度}を用いる
\emph{優先度順スケジューリング方式}を用いる．
将来，\|enice|の値を動的に変化させるように変更すれば，
\emph{動的優先度}方式になる．

%==============================================================================
\section{まとめ}
TacOSが時分割多重方式でCPUを仮想化する方法について解説した．
PCBとカーネルスタックを合わせてコンテキストの保存が行われる．
カーネルスタックはプロセス毎に割当てられコンテキストの大半が保存される．
PCBにはプロセスのSPだけを保存する．

また，タイマー処理を例に，
割込みが発生してプロセスが切換わるまでの処理概要を説明した．
ユーザプログラム実行中に割込みが発生するとカーネルモードに
切換わり割込みハンドラに制御が移る．
%{\cmml}の\|interrupt|型関数として実装された
ハンドラはユーザモードのコンテキストをプロセスのカーネルスタックに保存し，
その後マイクロカーネル内で必要な処理を行う．
処理の結果によりプロセスを切換える場合は\|yield()|関数を呼ぶ．

更に，プロセス切替えプログラムについて仕組みを解説した．
\|yield()|関数はアセンブリ言語で記述されており，
プロセスのカーネルモードのコンテキストを保存する．
\|dispatch()|関数もアセンブリ言語で記述されており，
プロセスのカーネルモードのコンテキストを復旧する．
コンテキストを復旧すると，
以前に\|yield()|関数を呼出した次の行からプロセスの実行が再開される．

最後に，スケジューラの例を紹介した．
\|schProc()|関数は実行可能列のプロセスが
優先度\|enice|の線形リストになるように新しいプロセスをリストに追加する．
