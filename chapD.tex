\chapter{仮想記憶}
仮想記憶は，
システムに実装されたよりも多くのメモリをプロセスが使用できるようにする．
仮想記憶を実現するために使用できるメモリ管理機構として，
\ref{chap:segmentation}章で学んだセグメンテーションと，
\ref{chap:paging}章で学んだページングがある．
既に\ref{chap:segmentation}章で，
セグメンテーション機構による仮想記憶は簡単に説明した．
しかし，セグメンテーションでは
物理メモリより大きなセグメントを使用することができない問題があった．

ページングを用いる方がメリットが多いので，
現代のオペレーティングシステムはページングによる仮想記憶を使用している．
この章ではページングに基づく仮想記憶方式について勉強する．

%==========================================================================
\section{基本概念}
ページングでは，
ページテーブルのVビットを使用して仮想アドレス空間にフレームが
割付けられていない状態を表現していた．
Vビットが0のページにアクセスするとページ不在割込みが発生し，
制御がオペレーティングシステムに移る．
Vビットが0の状態を上手く使うことで，
メモリより大きなプログラムでも実行できる仕組みを作る．

\figref{virtualMemoryBasic}に示すように，
ページの内容はフレームかディスク（\emph{バッキングストア}）に格納する．
ページの内容がフレームに置かれている時は
ページテーブルの対応するエントリのビットを1（V=1）にする．
フレームに置かれていない時はV=0とする．
V=0のページにアクセスするとページ不在割込みが発生する．
ページ不在の理由と対処方法は，
例えば以下のようにまとめられる．

\begin{enumerate}
\item 仮想アドレス空間の無効領域をアクセスし本当にエラーを起こした．\\
  → プロセスを終了する．
% \item スタックが隣のページ伸までびたが，
%   まだ，フレームが割り付けられていなかった．\\
%   → フレームを割当て，プロセスを再開する．
\item バッキングストアに内容が退避されているページにアクセスした．\\
  → フレームを割当て内容をディスクから復旧した後，プロセスを再開する．
\end{enumerate}

\myfigure{btp}{scale=0.66}{Fig/virtualMemoryBasic-crop.pdf}
         {仮想記憶の基本}{virtualMemoryBasic}

プロセス生成時にバッキングストアに仮想アドレス空間のイメージを作成する．
フレームはまだ割当てない．
プログラムが動作を開始するとページ不在割込みが発生し，
その都度，必要なページをバッキングストアから読み込む．

\section{デマンドページング}
ページングよる仮想記憶を用いると，
プロセス実行開始時にプログラム全体をメモリに読み込まなくても良い．
原理上は，一ページも読み込まなくても実行を開始することができる．
プログラムの最初の命令をフェッチする時点でページ不在割込みが発生し，
オペレーティングシステムによりページが読み込まれる．
このような，プログラムがアクセスした時点で
ページを読み込む方式を\emph{デマンドページング（Demand Paging）}と呼ぶ．
使用しないページをメモリに読み込むことがない点で無駄がない．
現代の多くのオペレーティングシステムで，
デマンドページング\footnote{デマンドページングの改良版も含む．}が
ページ読み込みの方式として採用されている．

\subsection{デマンドページングの手順}
デマンドページングの手順を以下にまとめる．

\begin{enumerate}
\item プロセスがV=0のページをアクセスする．
\item ページ不在割込みが発生しオペレーティングシステムに制御が移る．
\item オペレーティングシステムはプロセスがアクセスしたアドレスが
  正当なアドレスか調べる．\\
  不正なアドレスならプロセスを終了させる．（処理終わり）
\item 空きフレームを捜す．\\
  空きフレームが無い場合は何れかのフレームを選択し
  バッキングストアに書き出し（swap-out）空きフレームを作る．
\item 空きフレームをプロセスに割当て
  バッキングストアからページの内容を読み込む（swap-in）．
\item ページテーブ等を新しい状態に更新する．
\item ページ不在割込みを発生した命令の再実行からプロセスを再開する．
\end{enumerate}

\subsection{プログラムファイルの直接swap-inによる実行}
プログラムの機械語部分は変更されないので，
swap-out用のバッキングストアを準備する必要はない．
プログラムはデマンドページング方式で実行形式ファイルから直接swap-inする．
バッキングストアに予めプログラムをコピーしたり，
プログラムを予めフレームに読み込んだりしないので，
プログラムの起動を素早く行うことができる．
このアイデアを\figref{virtualMemoryWithZMagic}を用いて説明する．

\myfigure{btp}{scale=0.66}{Fig/virtualMemoryWithZMagic-crop.pdf}
         {デマンドページング}{virtualMemoryWithZMagic}

\begin{enumerate}
\item \emph{実行可能形式ファイルの構造} \\
  プログラムはデマンドページング用の実行可能形式ファイルに格納される．
  このファイルではデマンドページングで使用しやすいように，
  ページサイズの整数倍の境界からセグメントが配置されている．
  \begin{itemize}
  \item ヘッダはファイルがデマンドページング用の実行形式ファイルで
    あることを示すマジックナンバーで始まり，
    ファイル内のセグメントの大きさなどを記述している．
    ヘッダのサイズはページサイズと同じである．
  \item ヘッダの次に機械語プログラムを格納したセグメントが配置される．
    セグメントの大きさはページサイズの整数倍である．
    \figref{virtualMemoryWithZMagic}は
    プログラムのサイズが二ページの場合である．
  \item プログラムの次に初期化データが配置される．
    初期化データは初期値を明示したグローバル変数を集めた領域である．
  \end{itemize}
\item \emph{プログラムの読み込み} \\
  仮想アドレス空間の\emph{「プログラム１」}ページがアクセスされ
  ページ不在割込みが発生する．
  オペレーティングシステムがフレームを割り付け，
  実行可能形式ファイルから\emph{「プログラム１」}領域をswap-inする．
  プログラム領域は読み出し実行（R-X）だけが許可され，
  値が書き換えられることはない．
\item \emph{初期化データの読み込み} \\
  仮想アドレス空間の\emph{「データ」}ページがアクセスされ
  ページ不在割込みが発生する．
  オペレーティングシステムがフレームを割り付け，
  実行可能形式ファイルから\emph{「データ」}領域をswap-inする．
  データ領域は読み書き（RW-）が許可されるので値が変化する．
\item \emph{非初期化データとヒープ領域の割り付け} \\
  非初期化データ領域とヒープ領域は連続しているので，
  ここではヒープ領域としてまとめて説明する．
  仮想アドレス空間の\emph{「ヒープ」}ページがアクセスされ
  ページ不在割込みが発生する．
  オペレーティングシステムがフレームを割り付け内容をゼロでクリアする\footnote{
  C言語等の非期化グローバル変数の初期値がゼロだと保証される．}．
  ヒープ領域は読み書き（RW-）が許可されるので値が変化する．
\item \emph{スタック領域の割り付け} \\
  仮想アドレス空間の\emph{「スタック」}ページがアクセスされ
  ページ不在割込みが発生する．
  オペレーティングシステムがフレームを割り付け内容をゼロでクリアする\footnote{
  以前フレームを使用したプロセスの機密情報が漏洩しないようにクリアする．}．
  スタック領域は読み書き（RW-）が許可されるので値が変化する．
\end{enumerate}

\subsection{プログラムのswap-out}
プログラムを実行するに従い，
デマンドページングにより，
新しいページが次々とフレームに読み込まれる．
他のプロセスも同じように振る舞うので，やがてフレームが枯渇する．
使用頻度の低いフレームを解放し再利用できるようにする必要がある．
フレームを解放する際に内容をswap-outする場合がある．
以下では実行中のプロセスの，
各領域のフレームを解放する手順を簡単に述べる．

\begin{enumerate}
\item \emph{プログラム領域} \\
機械語プログラムは読み出し実行（R-X）だけ許可されたページに格納されるので，
swap-inされてから書き換わることはない．
再度，ページが必要になった時は，
実行可能形式ファイルから読み込めば良いので，
解放するフレームの内容をswap-outする必要はない．
二次記憶装置の使用領域とI/Oトラフィックを小さくすることができる．

\item \emph{初期化データ領域} \\
初期化データ領域は，初期値が格納された状態でswap-inされる．
読み書き可能（RW-）なのでプログラム実行中に書き換わる可能性がある．
ページテーブルのD（Dirty）ビットが0の場合は
読み込み時点から変更されていないのでswap-outする必要はない．
必要になったとき実行可能形式ファイルから読み出し直せば良い．
ページテーブルのD（Dirty）ビットが1の場合は，
フレームを再利用する前にバッキングストアにswap-outし，
次回必要になった時に復元できるようにする．

\item \emph{非初期化データ・ヒープ・スタック} \\
これらの領域は，ゼロで初期化されてから使用が開始される．
読み書き可能（RW-）なのでプログラム実行中に書き換わる可能性がある．
ページテーブルのD（Dirty）ビットが0の場合は
初期化時点から変更されていないので，
何もしないでフレームを解放しても良い．
ページテーブルのD（Dirty）ビットが1の場合は，
フレームを再利用する前にバッキングストアにswap-outし，
次回必要になった時に復元できるようにする．
\end{enumerate}

\section{Copy on Write}
UNIXのforkシステムコールはプロセスのコピー（子プロセス）を作る．
多くの場合，
子プロセスはすぐにexecveシステムコールを発行し新しい
プログラムの実行を開始するので，
せっかくコピーした仮想アドレス空間は余り活用されないまま廃棄される．
これでは効率が悪いのでアドレス空間を親子で共有するvforkシステムコールが
提供されるようになった．
vforkシステコールを用いる場合，
子プロセスがexecveするまで親プロセスは待ち状態になり，
共有のアドレス空間を破壊し合わないような工夫がされた．
その後，\emph{Copy on Write}と呼ばれるアドレス空間のコピーを遅らせる
技術が用いられるようになり，
forkシステムコールを用いても無駄なメモリコピーが起こらなくなった．

\begin{description}
\item[fork直後の様子]
  \figref{virtualMemoryFork}に示すように，
  Copy on Write を用いる場合，
  fork直後は親子プロセスでアドレス空間を共有する．
  この時点ではメモリのコピーはしない．
  その代わり，
  書き込み可能であるはずのデータ，ヒープ，スタック領域の
  メモリ保護を読み出し専用に設定する．

  \myfigure{btp}{scale=0.66}{Fig/virtualMemoryFork-crop.pdf}
           {fork直後の親子プロセス}{virtualMemoryFork}

\item[Copy on Writeの手順]
  どちらかのプロセスがスタックを書き換えようとした場合を例に，
  Copy on Write が働く手順を説明する．
  プロセスがスタック領域を書き換えようとすると
  メモリ保護割込みが発生しオペレーティングシステムに切り換わる．
  その後，オペレーティングシステムが次に述べる操作を行い，
  \figref{virtualMemoryCOW}に示す状態になる．

  \begin{enumerate}
  \item 新しいフレームを割当て，スタック領域フレームの内容をコピーする．
  \item 片方のプロセスのスタック領域に新しいフレームをマッピングする．
    もう一方のプロセスのスタック領域は古いフレームをマッピングしたままにする．
  \item 両プロセスのスタック領域の保護情報を読み書き（RW-）に変更する．
  \item 割込みを発生した命令の再実行からプロセスを再開する．
  \end{enumerate}

  \myfigure{btp}{scale=0.66}{Fig/virtualMemoryCOW-crop.pdf}
      {スタックでCopy on Writeが発生した時の親子プロセス}{virtualMemoryCOW}
\end{description}

以上のように書き込みが起こった時点でメモリがコピーされるので
Copy on Write と呼ばれる．

\section{メモリマップドファイル}
仮想記憶機構を用いてファイルを読み書きする手段を提供する．
仮想アドレス空間をファイルにマッピングすることで，
ユーザプログラムはメモリ（配列）を操作する手順でファイルを読み書きできる．
ファイル操作の度にシステムコールを発行しない軽いファイル操作手段である．
また，複数のプロセスが同じファイルをマッピングすることで，
プロセス間の広帯域のデータ共有手段にもなる．

\subsection{UNIXのメモリマップドファイル}
まず，実際にメモリマップドファイルを使用する例を示す．
UNIXではmmapシステムコール\footnote{
Windowsでは\texttt{CreateFileMapping()}関数をが使用できる．} を用いて
仮想アドレス空間とファイルを関連付ける．
ファイルを仮想アドレス空間上の配列としてアクセスすることができる．
以下に，mmapシステムコールのプロトタイプ宣言と簡単な解説を掲載する．

\begin{lstlisting}[numbers=none]
void * mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);
\end{lstlisting}

\begin{description}
\item[\emph{戻り値}：]
  マップされた領域の先頭アドレスが返される．
  アドレスはページサイズの倍数になる．
\item[\texttt{addr}：]
  マップしたい仮想アドレス空間の先頭アドレスを渡す．
\item[\texttt{len}：]
  マップする領域の大きさを渡す．
  大きさはページサイズの倍数にする．
\item[\texttt{prot}：]
  保護モード（protection）を表す値を渡す．
  ページの保護モード（RWX）が決まる．
\item[\texttt{flags}：]
  マップドファイルをプロセス間で共用する（\|MAP_SHARED|）か，
  プロセスにプライベート（\|MAP_PRIVATE|）にするか等を表すフラグを渡す．
\item[\texttt{fd}：]
  オープン済みファイルのファイルディスクリプタを渡す．
\item[\texttt{offset}：]
  ファイルの\texttt{offset}バイトから始まる
  \texttt{len}バイトをマッピングする．
  \texttt{offset}はページサイズの倍数にする．
\end{description}

リスト\ref{mmapTest}に
ファイルの内容を配列のように書き換えるプログラムの例を掲載する．
このプログラムを実行すると予め作成しておいた\texttt{a.txt}ファイルの
最初の4KiBが英大文字で上書きされる．

\lstinputlisting[numbers=left,float=btp,
  caption=メモリマップドファイルの使用例,label=mmapTest]{Lst/mmapTest.c}

\begin{description}
\item[8行] 予め作成しておいた4KiBのファイルを開く．
  プロセスがメモリマップを通してファイルに読み書き両方ができるためには，
  openシステムコールのフラグに\|O_RDWR|を渡す必要がる．
\item[13行] 仮想アドレス空間に8行でオープンしたファイルをマッピングする．
  マッピングするアドレスの決定をカーネルに任せるので第１引数は\|NULL|にする．
  書き込んだ内容をファイルに反映するために\|MAP_SHARED|を指定する．
\item[18行] mmapシステムコールが完了したらファイルはクローズして構わない．
\item[19〜21行] mmapが返した領域を文字型の配列と見做して文字を書き込む． 
  値をファイルに反映するために特別な操作をする必要はない．
\end{description}

\subsection{メモリマップドファイルの仕組み}
\figref{virtualMemoryWithMmap}に，
二つのプロセスの仮想アドレス空間に
同じファイルの同じ部分をマップした例を示す．
UNIXのmmapシステムコールで\|MAP_SHARED|フラグを使用した場合に相当する．
この例では，
ファイルは読み書きの両方ができるようにマップされている．
二つのプロセスは同じフレームを共用し，
共有メモリを持った状態でもある．

\myfigure{btp}{scale=0.66}{Fig/virtualMemoryWithMmap-crop.pdf}
         {プロセス間で共有したメモリマップドファイル}{virtualMemoryWithMmap}

\figref{virtualMemoryWithMmap}は，
ファイルの内容がフレームに読み込まれた状態を表している．
しかし，mmapシステムコール実行直後は，図とは異なり，
フレームが割当てられていない．
mmapはページとファイルを関連付けるが，
実際にファイルを読み書きするのは仮想記憶の仕組みによる．
以下に，メモリマップドファイルが読み書きされる仕組みを説明する．

\begin{enumerate}
\item \emph{ファイルの読み込み} \\
  マップされたアドレスをプロセスがアクセスした時点で，
  ファイルの該当箇所がデマンドページングの要領でフレームに読み込まれる．
\item \emph{ファイルの書き込み} \\
  定期的に変更のあった（Dirty）ページをファイルに書き戻す．
  また，プロセスが終了したりマッピングが解除された時も
  ファイルに書き戻す．
\end{enumerate}

\subsection{read/writeシステムコールとの比較}
メモリマップドファイルの場合，
フレーム上のデータが参照されたり変更される度に，
ファイルの書き換えが起こるわけではなく，
効率の良いファイルの参照が可能である．

一方でread/writeシステムコールの場合は，
ディスクキャッシュを用いて二次記憶装置のアクセス回数を
少なくする工夫がされる．
しかし，read/writeシステムコールの引数として渡されたバッファと
ディスクキャッシュの間でメモリコピーをする必要がある．
\figref{mmapVsReadWrite}に，
read/writeシステムコールを使用する場合のデータの流れを模式的に示す．
メモリコピーは一般に重い処理である．

\myfigure{btp}{scale=0.66}{Fig/mmapVsReadWrite-crop.pdf}
         {read/writeシステムコールのデータコピー}{mmapVsReadWrite}

また，read/writeの場合はデータの読み書きの度にシステムコールを発行する．
一方でメモリマップドファイルの場合，
mmapシステムコールを用いてマッピングを完了してしまえば
システムコールを発行する必要がない．
システムコールも一般に重い処理である．

\subsection{プロセスにローカルなマッピング}
\figref{virtualMemoryWithPrivateMap}に，
二つのプロセスの仮想アドレス空間に
同じファイルの同じ部分を\emph{ローカルに}マップした例を示す．
UNIXのmmapシステムコールで\|MAP_PRIVATE|フラグを使用した場合に相当する．

\begin{itemize}
\item \emph{「ファイルデータ１」}領域 \\
プロセスの仮想アドレス空間にマップされ，かつ，プロセスに参照された．
参照された時点でフレームに読み込まれプロセスから見える状態になっている．
\item \emph{「ファイルデータ２」}領域 \\
一旦，「ファイルデータ１」のように参照されフレームに読み込まれた．
その後，プロセスが値を書き換えた．
\|MAP_PRIVATE|の場合は他のプロセスやファイルに変更が反映されない．
\emph{Copy on Write}方式でコピーが作られ，
プロセス毎に別のコピーが参照されるようにマッピングする．
\end{itemize}

\myfigure{btp}{scale=0.66}{Fig/virtualMemoryWithPrivateMap-crop.pdf}
         {プロセスにローカルなマッピングの例}{virtualMemoryWithPrivateMap}

\subsection{プログラムの実行とメモリマップドファイル}
メモリマップドファイルの仕組みと，
\figref{virtualMemoryWithZMagic}で見た
デマンドページングによるプログラムの実行は，
よく似ている．
以下のようにメモリマップドファイルを用いると，
デマンドページングが実現できる．

\begin{itemize}
\item 実行形式ファイルをメモリにマッピングする．
  \begin{itemize}
  \item プログラムは，\|R-X|，\|MAP_SHARD|でマッピングする．
    （プログラムはプロセス間で共用される）
  \item 初期化データは，\|RW-|，\|MAP_PRIVATE|でマッピングする．
    書き込みが起きた時点でバッキングストアと結びつける．
  \end{itemize}
\item 非初期化データ，ヒープ，スタックはファイルにマッピングしない．
\end{itemize}
