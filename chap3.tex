\chapter{CPUの仮想化}
これまでに述べたように，
オペレーティングシステムはハードウェアを抽象化した，
使いやすい拡張マシン（仮想マシン）を必要な数だけ提供する．
数に限りがある必要な数だけあるように見せるために仮想化が行われる．
CPUも仮想化し，
各プロセスが自分専用のCPUを持っているように見せかける．

\section{時分割多重}
CPUを仮想化するためには時分割多重を用いる．
ハードウェアである実CPUの数は限られているので，
時間を区切って実CPUを使用するプロセスを次々に切換えていく．
\figref{virtualCPU}にCPU仮想化の原理を示す．

図で実CPUは\figref{cpuBlock}のような構造をもつハードウェアである．
プロセスの構造は\figref{procOrganization}に示した通りであり，
仮想CPUを含んでいる．
実CPUが短時間（例えば10ms毎）に次々と実行するプロセスを切換えていくことで，
複数のプロセスが夫々に専用のCPUを持ち並行して実行されているように見せかける．

その際，切換える直前のCPUのコンテキストをプロセスの仮想CPU領域に保存する．
次に新しく実行するプロセスの仮想CPU領域にからコンテキストを実CPUに読込み，
新しいプロセスの実行を再開する．
実CPUにコンテキストを読込んで実行を再開することを{\bf ディスパッチ}と言う．
ディスパッチを行うプログラムを{\bf ディスパッチャ}と呼ぶ．
\figref{osOrganization}にもディスパッチャは描かれていた．

\myfigure{btp}{scale=0.7}{virtualCPU-crop.pdf}
{時分割多重によるCPUの仮想化}{virtualCPU}

\section{プロセスの状態}
プロセスはキーボド等の入出力装置からの入力を待つ状態になったり，
時間が経過するのを待つ状態になったりする．
{\bf 待ち}状態のプロセスにはCPUを割当てる必要がない．
このようにプロセスは幾つかの状態を持っている．
プロセスの状態はUNIXではpsコマンドで確認できる．
プロセスを模式的に示した\figref{procOrganization}では，
「プロセス情報」の「プロセスの状態」のことである．
次にプロセスの最も基本的な三つの状態を説明する．

\begin{itemize}
\item Ready（実行可能） \\
CPUを割当てれば実行を開始できる状態のことである．
プロセスはCPUが割当てられるのを待っている．
\item Running（実行中） \\
CPUが割当てられて実行中の状態のことである．
CPUの数より多くのプロセスが同時にRunningになることはできない．
\item Wating（待ち） \\
シグナルの到着や入出力の完了等の事象を待っている状態のことである．
\end{itemize}

\figref{procState}にプロセスの状態遷移図を示す．
図に示された六つの状態遷移の意味は以下の通りである．

\begin{enumerate}
\item Create（生成） \\
新しいプロセスが生成されるとReady状態になる．

\item Dispatch（派遣） \\
Ready状態のプロセスはCPUが割当てられRunningに遷移する．

\item Preemption（横取り） \\
Runningのプロセスは，
決められた時間（クオンタムタイム）を使い切ったとき，
より優先度の高いプロセスがReadyになったとき等に，
CPUを取り上げられてReady状態に遷移する．

\item Block（事象待ち） \\
Runningのプロセスが，
システムコールを発行して自らWaiting状態に遷移することがある．
例えば入出力システムコール
（\|open()|，\|read()|，\|write()|，\|close()|等）や，
シグナル待ちシステムコール（\|pause()|，\|wait()|，\|sleep()|等）
を発行した場合である．
また，他のプロセスからシグナルを受信したり，
優先度の高いプロセスが実行可能になった場合も，
Waiting状態に遷移することがある．

\item Complete（事象完了） \\
入出力の完了，
シグナルの発生等により
システムコールが完了するとReady状態に遷移する．

\item Exit（終了） \\
プロセスが自らシステムコール（\|exit()|）を用いて終了する場合，
プロセスがシグナルを受ける等して終了させられる場合に
この遷移が起こる．
\end{enumerate}

\myfigure{btp}{scale=0.7}{procState-crop.pdf}{プロセスの状態遷移}{procState}

\section{プロセスの切換え}
プロセスはCPUが割当てられ状態がRunningになって実行される．
RunningのプロセスはWaitingまたはReadyに状態遷移する際に，
CPUを取り上げられる．

\subsection{切換えの原因}
プロセスの状態遷移が起こる原因を以下にまとめ直す．
プロセスが以下の二つの原因により状態遷移を起こすことにより，
実行を開始したり待ち状態になったりする．

\begin{enumerate}
\item イベント \\
プロセスが自ら「システムコールを発行」することでBlock遷移をすることがある．
入出力待ちのプロセスが「入出力完了」によりComplete遷移をすることがある．
時間待ちのプロセスが「時刻になった」時にComplete遷移をすることがある．
他のプロセスからの「干渉\footnote{
干渉には，より優先順位の高いプロセスが実行可能になった，
別のプロセスからシグナル等を受取った等がある．}
を受け」Block遷移やComplete遷移をすることがある．

\item タイムスライシング \\
Runningのプロセスが連続して実行しても良い時間（クオンタムタイム）を使い切り，
Preemption遷移をする．
Preemption遷移した後，
もしも優先度の高い他のプロセスがReadyならそのプロセスに切替わる．
優先度の高いプロセスにReadyのものが無ければDispatch遷移し，
再度，Runningに状態になる．
\end{enumerate}
